import { v4 as uuidv4 } from 'uuid';

async function handleCORS(request) {
    const headers = new Headers();
    headers.set('Access-Control-Allow-Origin', '*');
    headers.set('Access-Control-Allow-Methods', 'GET, POST, DELETE');
    headers.set('Access-Control-Allow-Headers', 'Content-Type');
    return headers;
}

async function authenticateRequest(request) {
    // Implement your authentication logic here.
    return true; // For now, we'll just return true.
}

function isValidNotification(notification) {
    if (
        typeof notification !== 'object' ||
        !['alert', 'info', 'success'].includes(notification.type) ||
        typeof notification.content !== 'object' ||
        typeof notification.content.text !== 'string' ||
        typeof notification.read !== 'boolean'
    ) {
        return false;
    }
    return true;
}


export async function onRequestPost({ request, env }) {
    const corsHeaders = handleCORS(request);

    // if (!await authenticateRequest(request)) {
    //     return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    // }
    
    let notifications;
    try {
        notifications = await request.json();
    } catch (err) {
        return new Response('Invalid JSON', { status: 400, headers: corsHeaders });
    }

    if (!Array.isArray(notifications)) {
        notifications = [notifications];
    }

    for (const notification of notifications) {
        if (!isValidNotification(notification)) {
            return new Response('Invalid notification format', { status: 400, headers: corsHeaders });
        }
    }
    // console.log(env.BINDING);
    const responses = [];
    for (const notification of notifications) {
        const id = uuidv4();
        const timestamp = Date.now();
        const notificationWithMeta = {
            notification,
            id,
            timestamp
        };
        try {
            await env.NOTIFICATIONS.put(id, JSON.stringify(notificationWithMeta));
            responses.push(notificationWithMeta);
        } catch (err) {
            console.error('Error storing notification in KV:', err);
            return new Response('Error storing notification', { status: 500, headers: corsHeaders });
        }
    }

    // Return the notification response as Array .
    return new Response(JSON.stringify(responses), { status: 201, headers: corsHeaders });
}

export async function retrieveNotifsFromKVStore(env) {
    const notifications = [];
    const list = await env.NOTIFICATIONS.list();
    for (const key of list.keys) {
        const notification = await env.NOTIFICATIONS.get(key.name);
        if (notification) {
            notifications.push(JSON.parse(notification));
        }
    }
    return notifications;
}

export async function onRequestGet({ env }) {
    const corsHeaders = handleCORS();

    const notifications = await retrieveNotifsFromKVStore(env);
    return new Response(JSON.stringify([...notifications]), { status: 200, headers: corsHeaders });
}

export async function deleteAllAutoGeneratedNotifsFromKV(env) {
    const list = await env.NOTIFICATIONS.list();
    for (const key of list.keys) {
        await env.NOTIFICATIONS.delete(key.name);
    }
}

export async function onRequestDelete({ env }) {
    const corsHeaders = handleCORS();

    await deleteAllAutoGeneratedNotifsFromKV(env);
    // Removal of notifications is successfull.
    return new Response(JSON.stringify({ message: 'Notifications deleted successfully!' }), { status: 200, headers: corsHeaders });
}
